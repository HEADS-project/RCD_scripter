/* RCD scriptgrammar.jj version 2 using task joblist*/
options {
  MULTI=true;
  NODE_DEFAULT_VOID=true;
  NODE_PACKAGE="org.thingml.rcd_scripter3.parser";
  STATIC = false ;
}

PARSER_BEGIN (RcdScript3Parser)
   package org.thingml.rcd_scripter3.parser;
   import java.io.FileReader;
   import org.thingml.rcd_scripter3.parser.ASTRcdLiteral.ValType;
   public class RcdScript3Parser {
        private String fileName;
        public ASTRcdStart makeAst()throws ParseException, TokenMgrError
        {
            token_source.defaultLexState = IN_RCD_SKIP_REGION; 
            token_source.curLexState = IN_RCD_SKIP_REGION; 
                return(Start()); 
        }

        public void setFileName(String name) {
            fileName = name;
        }

   }
PARSER_END (RcdScript3Parser)

SKIP: /* WHITE SPACE */ { "\n" | "\r" | "\r\n" | "\\" | "\t" | " " | "//" | "*/" | "/*"}

/* COMMENTS */

MORE :
{
  "RCD_SCRIPT_STOP" : IN_RCD_SKIP_REGION
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "##" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")?>
}


<IN_RCD_SKIP_REGION>
SPECIAL_TOKEN :
{
  <RCD_SKIP_REGION: "RCD_SCRIPT_START" > : DEFAULT
}

<IN_RCD_SKIP_REGION>
MORE :
{
  < ~[] >
}



TOKEN [IGNORE_CASE]: /* Commands */
{
  <INCLUDE :("INCLUDE")>
|
  <FOR :("FOR")>
|
  <PROC :("PROC")>
|
  <RETURN :("RETURN")>
|
  <EXIT :("EXIT")>
|
  <IF:("IF")>
|
  <ELSE:("ELSE")>
|
  <WHILE:("WHILE")>
|
  <TRUE:("TRUE")>
|
  <FALSE:("FALSE")>
|
  <RCD_SCRIPT_END: ("RCD_SCRIPT_END")>
|
  <AND:("AND")>
|
  <OR:("OR")>

}


TOKEN :  /* Literals */
{
  < VAR_LITERAL: <DOLLAR><ID_LITERAL> >
|
  < ID_LITERAL: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < DEC_LITERAL: (<DIGIT>)+ >
|
  < FLOAT_LITERAL: (<DIGIT>)+ <PERIOD> (<DIGIT>)+ (<DECIMAL_EXPONENT>)? >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < HEX_LITERAL: "0" ["x","X"] (<HEX_DIGIT>)+ >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

TOKEN :  /* Character groups */
{
  < LETTER: [ "a"-"z", "A"-"Z", "_" ] >
|
  < DIGIT: [ "0"-"9"] >
|
  < HEX_DIGIT: [ "0"-"9", "a"-"f", "A"-"F"] >
}

TOKEN:  /* Separators */
{
    <OBRA:("(")>
|
    <CBRA:(")")>
|
    <OCBRA:("{")>
|
    <CCBRA:("}")>
|
    <OABRA:("[")>
|
    <CABRA:("]")>
|
    <COMMA:(",")>
|
    <PERIOD:(".")>
|
    <SEMI:(";")>
|
    <COLON:(":")>
|
    <QUESTION:("?")>
|
    <ASSIGN:("=")>
|
    <EQUAL:("==")>
|
    <GT:(">")>
|
    <LT:("<")>
|
    <GTE:(">=")>
|
    <LTE:("<=")>
|
    <NOTEQUAL:("!=")>
|
    <DOLLAR:("$")>
|
    <PLUS:("+")>
|
    <MINUS:("-")>
|
    <INCR:("++")>
|
    <DECR:("--")>
|
    <MUL:("*")>
|
    <DIV:("/")>
}


ASTRcdStart Start() #RcdStart : {}
{
	Script()
    <RCD_SCRIPT_END>
    {return jjtThis;}
}

void Script() : {}
{
    (
		Include()
		|
        DeclProc()
        |
        Block()
        |
        Statement()
    )*
}

void Include() :
{
    Token t;
	String fileName;
    RcdScript3Parser subParser;
    ASTRcdStart subAst;
}
{
    <INCLUDE>
    <OBRA>
    t = <STRING_LITERAL>
    <CBRA>
    <SEMI>
    {
        fileName = t.image.substring(0, t.image.length()-1).substring(1); // Remove quotes
		System.out.println("Starting to include " + fileName);
        try{
			subParser = new RcdScript3Parser(new FileReader(fileName)); 
			subAst = subParser.makeAst(); 
            subAst.dump("Include: ");
			
			if (subAst.children != null) {
				for (int i = 0; i < subAst.children.length; ++i) {
					jjtree.openNodeScope(subAst.children[i]);
					jjtree.closeNodeScope(subAst.children[i], true);
				}
			}
		}
        catch (Exception ex) 
        {
            ex.printStackTrace();
        }
		System.out.println("End of include " + fileName);
	}
}

// ************* DeclProc ***************
void DeclProc() #RcdDeclProc :
{
    Token t;
}
{
    (
        <PROC>
        t = <ID_LITERAL>
        <OBRA>
            FormParamNode()
        <CBRA>
        <OCBRA>
        ScriptNode("ProcScript")
        <CCBRA>
    )
    {
	    jjtThis.setName(t.image);
        jjtThis.setToken(token);
	}
}

void FormParamNode() #RcdNode :
{
}
{
    { jjtThis.setName("FormParam"); }
    (
        FormParam()
        (
            <COMMA>
            FormParam()
        )*
    )?
}

void FormParam() #RcdFormParam:
{
    Token t;
}
{
    t = <VAR_LITERAL>
    {
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

// ************* Block ***************

void Block() :
{
}
{
	IfBlock()
	|
	WhileBlock()
	|
	ForBlock()
}

void IfBlock() #RcdIfBlock :
{
}
{
	<IF>
    { jjtThis.setToken(token); }
	<OBRA>
	ExprNode()
	<CBRA>
    <OCBRA>
	ScriptNode("TrueScript")
    <CCBRA>
	(
		<ELSE>
        <OCBRA>
		ScriptNode("FalseScript")
        <CCBRA>
	)?
}

void WhileBlock() #RcdWhileBlock :
{
}
{
	<WHILE>
    { jjtThis.setToken(token); }
	<OBRA>
	ExprNode()
	<CBRA>
    <OCBRA>
	ScriptNode("TrueScript")
    <CCBRA>
}

void ForBlock() #RcdForBlock :
{
}
{
	<FOR>
    { jjtThis.setToken(token); }
	<OBRA>
    (
        LOOKAHEAD(Var()<COLON>)
        (
            Var()
            <COLON>
            ExprNode()
        )
        |
        (
            VarXXX()
            <SEMI>
            ExprNode()
            <SEMI>
            ExprNode()
        )
    )
	<CBRA>
	<OCBRA>
	ScriptNode("ForScript")
    <CCBRA>
}

void ScriptNode(String nodeName) #RcdNode :
{
}
{
    { jjtThis.setName(nodeName); }
	Script()
}

// ************* Statement ***************

void Statement() :
{
}
{
	(
        VarXXX()
        |
        ReturnStmt()
        |
        ExitStmt()
	)
	<SEMI>
}

void VarXXX() :
{
}
{
    (
        Var()
        |
        Id()
    )
    VarIAC()
}

void VarIAC() :
{
}
{
    (
        IndexOabra(true)
        |
        IndexPeriod(true)
    )*
    (
        CallParam(false)
        |
        Assign()
    )?
}

void CallParam(boolean returnValue) #RcdCallIdOnStackParam :
{
}
{
	<OBRA>
    { 
        jjtThis.setToken(token); 
        jjtThis.setReturnValue(returnValue);
    }
    ActParamNode()
	<CBRA>
}

void ActParamNode() #RcdNode :
{
}
{
    { jjtThis.setName("ActParam"); }
    (
        ExprNode()
        (
            <COMMA>
            ExprNode()
        )*
    )?
}

void IndexOabra(boolean assign) #RcdIndex:
{
    Token t;
}
{
    (
        t = <OABRA>
        ExprNode()
        <CABRA>
    )
    {
        jjtThis.setName("INDEX");
        jjtThis.setToken(t); 
        jjtThis.setAssign(assign); 
    }
}

void IndexPeriod(boolean assign) #RcdIndex:
{
    Token t;
}
{
    (
        t = <PERIOD>
        (
            Id()
            |
            Var()
            |
            Literal()
            |
            <OBRA> ExprNode() <CBRA> 
        )
    )
    {
        jjtThis.setName("INDEX");
        jjtThis.setToken(t); 
        jjtThis.setAssign(assign); 
    }
}

void Assign() #RcdAssign:
{
    Token t;
}
{
	t = <ASSIGN>
    {
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
	ExprNode()
}


void ReturnStmt() #RcdReturnStmt :
{
}
{
	<RETURN>
    { jjtThis.setToken(token); }
	<OBRA>
    (
        ExprNode()
    )?
}

void ExitStmt() #RcdExitStmt :
{
}
{
	<EXIT>
    { jjtThis.setToken(token); }
	<OBRA>
    (
        ExprNode()
    )?
}

// ************* Expression grammar ***************

void ExprNode() #RcdNode :
{
}
{
    { jjtThis.setName("ExprNode"); }
    (
        LOOKAHEAD(OrExpr()<QUESTION> )
        CondExpr()
        |
        OrExpr()
    )
}

void CondExpr() #RcdCondExpr : 
{
}
{
    OrExprNode()
    <QUESTION>
    ExprNode()
    <COLON>
    ExprNode()
}

void OrExprNode() #RcdNode :
{
}
{
    { jjtThis.setName("OrExprNode"); }
	OrExpr()
}

void OrExpr() : 
{
}
{
    AndExpr() 
	( 
		OrExprFollow() 
	)*
}

void OrExprFollow() #RcdOpExpr : 
{
    Token t;
}
{
	( 
		t = <OR>
	) 
	AndExpr() 
	{
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void AndExpr() : 
{
}
{
    CmpExpr() 
	( 
		AndExprFollow() 
	)*
}

void AndExprFollow() #RcdOpExpr : 
{
    Token t;
}
{
	( 
		t = <AND>
	) 
	CmpExpr() 
	{
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void CmpExpr() : 
{
}
{
    AddExpr() 
	( 
		CmpExprFollow() 
	)?
}

void CmpExprFollow() #RcdOpExpr : 
{
    Token t;
}
{
	( 
		t = <EQUAL>
		|
		t = <GT>
		|
		t = <LT>
		|
		t = <GTE>
		|
		t = <LTE>
		|
		t = <NOTEQUAL>
	) 
	AddExpr() 
	{
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void AddExpr() : 
{
}
{
    MulExpr() 
	( 
		AddExprFollow() 
	)*
}

void AddExprFollow() #RcdOpExpr: 
{
    Token t;
}
{
    ( 
        t = <PLUS>
        |
        t = <MINUS>
    ) 
    MulExpr() 
    {
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void MulExpr() : 
{
}
{
    UnaryExpr() 
	( 
        MulExprFollow()
	)*
}

void MulExprFollow() #RcdOpExpr: 
{
    Token t;
}
{
    ( 
        t = <MUL>
        |
        t = <DIV>
    ) 
    UnaryExpr() 
    {
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void UnaryExpr() : 
{
    Token t = null;
}
{
    (
        PreExpr()
    )
    |
    (
        PrimExprPrefix()
        PrimExprSuffix()
    )
}

void PreExpr() #RcdOpExpr: 
{
    Token t;
}
{
    (
        t = <INCR>
        |
        t = <DECR>
        |
        t = <PLUS>
        |
        t = <MINUS>
    )
    UnaryExpr()
    {
        jjtThis.setName("pre"+t.image);
        jjtThis.setToken(t); 
    }
}

void PrimExprPrefix() : 
{
}
{
    <OBRA> ExprNode() <CBRA> 
    |
    Literal()
    |
    Var() 
    |
    Id() 
}

void PrimExprSuffix() : 
{
}
{
    (
        IndexOabra(false)
        |
        IndexPeriod(false)
    )*

    (
        CallParam(true)
    )?

    (
        PostIncrDecr()
    )?
}

void PostIncrDecr() #RcdOpExpr: 
{
    Token t;
}
{
    (
        t = <INCR>
        |
        t = <DECR>
    )
    {
        jjtThis.setName("post"+t.image);
        jjtThis.setToken(t); 
    }
}

void Var() #RcdVar:
{
    Token t;
}
{
    t = <VAR_LITERAL>
    {
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void Id() #RcdLiteral :
{
    Token t;
}
{
    t = <ID_LITERAL>
    {
        jjtThis.setValType(ValType.ID);
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

// ************* Literal value grammar ***************

void Literal() : 
{
    Token t;
}
{
    StringVal()
    |
    IntVal()
    |
    BoolVal()
    |
    RealVal()
    |
    ArrayVal()
}

void StringVal() #RcdLiteral :
{
    Token t;
}
{
    t = <STRING_LITERAL>
    {
        jjtThis.setValType(ValType.STRING);
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void IntVal() #RcdLiteral :
{
    Token t;
}
{
    (
        t = <DEC_LITERAL>
		|
        t = <HEX_LITERAL>
	)
    {
        jjtThis.setValType(ValType.INT);
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void BoolVal() #RcdLiteral :
{
    Token t;
}
{
    (
        t = <TRUE>
        |
        t = <FALSE>
	)
    {
        jjtThis.setValType(ValType.BOOL);
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void RealVal() #RcdLiteral :
{
    Token t;
}
{
    t = <FLOAT_LITERAL>
    {
        jjtThis.setValType(ValType.REAL);
        jjtThis.setName(t.image);
        jjtThis.setToken(t); 
    }
}

void ArrayVal() #RcdArrayVal :
{
}
{
    (
        <OCBRA> 
        {
            jjtThis.setToken(token); 
        }
        Tupl()
        ( 
            <COMMA>
            Tupl()
        )*
        <CCBRA> 
    ) 
}

void Tupl() : 
{
}
{
    (
        ExprNode()
        (
            <COLON>
                {
                    jjtThis.setToken(token); 
                }
            ExprNode() 
        )?
    ) #RcdTupl(>1)
}

